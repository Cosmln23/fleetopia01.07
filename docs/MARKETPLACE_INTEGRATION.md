# MARKETPLACE INTEGRATION - AGENT CONNECTION

**Current Status**: Agent reads mock marketplace data  
**Target**: Full integration with production marketplace system

---

## 🎯 INTEGRATION OVERVIEW

Connect the Dispatcher AI Agent with the existing Marketplace system for:
- Real cargo offer processing
- Quote generation and submission
- Feedback loop with offer acceptance/rejection
- Integration with existing offer_requests system

---

## 📋 INTEGRATION CHECKLIST

### 1. MARKETPLACE API ENHANCEMENTS

**Update**: `/app/api/cargo/route.ts`

Add agent-specific endpoints for reading cargo offers:

```typescript
// Add to existing GET endpoint
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const agentMode = searchParams.get('agent')
  
  if (agentMode === 'true') {
    // Return cargo in agent-friendly format
    try {
      const result = await pool.query(`
        SELECT 
          c.*,
          COUNT(or.id) as existing_offers
        FROM cargo c
        LEFT JOIN offer_requests or ON or.cargo_id = c.id
        WHERE c.status IN ('NEW', 'OPEN')
        AND c.created_at > NOW() - INTERVAL '48 hours'
        GROUP BY c.id
        HAVING COUNT(or.id) < 3  -- Limit offers per cargo
        ORDER BY c.created_at DESC
      `)
      
      return Response.json(result.rows)
    } catch (error) {
      return Response.json({ error: 'Database error' }, { status: 500 })
    }
  }
  
  // Existing marketplace logic...
}
```

**Create**: `/app/api/cargo/agent-compatible/route.ts`

```typescript
import { NextRequest } from 'next/server'
import { pool } from '@/lib/db'

export async function GET() {
  try {
    // Get cargo offers with complete geocoding data for agent
    const result = await pool.query(`
      SELECT 
        c.*,
        -- Calculate route distance if pickup/delivery coordinates exist
        CASE 
          WHEN c.from_lat IS NOT NULL AND c.to_lat IS NOT NULL 
          THEN (
            6371 * acos(
              cos(radians(c.from_lat)) * 
              cos(radians(c.to_lat)) * 
              cos(radians(c.to_lng) - radians(c.from_lng)) + 
              sin(radians(c.from_lat)) * 
              sin(radians(c.to_lat))
            )
          )
          ELSE NULL 
        END as route_distance_km,
        -- Count existing offers
        COUNT(or.id) as offer_count
      FROM cargo c
      LEFT JOIN offer_requests or ON or.cargo_id = c.id
      WHERE c.status IN ('NEW', 'OPEN')
      AND c.created_at > NOW() - INTERVAL '24 hours'
      -- Only include cargo with coordinates for agent processing
      AND c.from_lat IS NOT NULL 
      AND c.from_lng IS NOT NULL
      AND c.to_lat IS NOT NULL 
      AND c.to_lng IS NOT NULL
      GROUP BY c.id
      HAVING COUNT(or.id) < 5  -- Limit competition
      ORDER BY c.urgency DESC, c.created_at DESC
    `)
    
    return Response.json(result.rows)
  } catch (error) {
    return Response.json({ error: 'Agent cargo fetch failed' }, { status: 500 })
  }
}
```

---

### 2. OFFER REQUESTS INTEGRATION

**Update**: `/app/api/offer-requests/route.ts`

Add agent submission capability:

```typescript
export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { cargoId, proposedPrice, message, agentSuggestionId } = body
    
    // Validate agent suggestion if provided
    if (agentSuggestionId) {
      const suggestionResult = await pool.query(`
        SELECT * FROM agent_suggestions 
        WHERE id = $1 AND cargo_id = $2 AND status = 'PENDING'
      `, [agentSuggestionId, cargoId])
      
      if (suggestionResult.rows.length === 0) {
        return Response.json({ error: 'Invalid agent suggestion' }, { status: 400 })
      }
    }
    
    // Create offer request
    const result = await pool.query(`
      INSERT INTO offer_requests (
        cargo_id, provider_name, proposed_price, message, 
        status, agent_suggestion_id, created_at
      ) VALUES ($1, $2, $3, $4, 'PENDING', $5, NOW())
      RETURNING *
    `, [
      cargoId,
      'FleetOpia AI Agent',
      proposedPrice,
      message || 'Automated quote generated by AI dispatcher',
      agentSuggestionId || null
    ])
    
    // Update agent suggestion status if applicable
    if (agentSuggestionId) {
      await pool.query(`
        UPDATE agent_suggestions 
        SET status = 'SENT', sent_at = NOW()
        WHERE id = $1
      `, [agentSuggestionId])
    }
    
    return Response.json(result.rows[0], { status: 201 })
    
  } catch (error) {
    return Response.json({ error: 'Failed to create offer request' }, { status: 500 })
  }
}
```

**Create**: `/app/api/offer-requests/[id]/agent-response/route.ts`

```typescript
import { NextRequest } from 'next/server'
import { pool } from '@/lib/db'

export async function PATCH(
  request: NextRequest, 
  { params }: { params: { id: string } }
) {
  try {
    const body = await request.json()
    const { status, feedback } = body // ACCEPTED, REJECTED, COUNTER_OFFER
    
    // Update offer request status
    await pool.query(`
      UPDATE offer_requests 
      SET status = $1, responded_at = NOW()
      WHERE id = $2
    `, [status, params.id])
    
    // Update related agent suggestion
    const offerResult = await pool.query(`
      SELECT agent_suggestion_id FROM offer_requests WHERE id = $1
    `, [params.id])
    
    if (offerResult.rows[0]?.agent_suggestion_id) {
      const suggestionStatus = status === 'ACCEPTED' ? 'ACCEPTED' : 'REJECTED'
      
      await pool.query(`
        UPDATE agent_suggestions 
        SET status = $1, responded_at = NOW()
        WHERE id = $2
      `, [suggestionStatus, offerResult.rows[0].agent_suggestion_id])
      
      // Record feedback for learning
      await pool.query(`
        INSERT INTO agent_feedback (
          suggestion_id, feedback_type, notes, created_at
        ) VALUES ($1, $2, $3, NOW())
      `, [
        offerResult.rows[0].agent_suggestion_id,
        status,
        feedback || null
      ])
    }
    
    return Response.json({ success: true })
    
  } catch (error) {
    return Response.json({ error: 'Failed to update offer response' }, { status: 500 })
  }
}
```

---

### 3. AGENT MARKETPLACE POLLING

**Update**: `/lib/agent-production.ts`

Modify L0 Radar to use real marketplace:

```typescript
// Update runL0Radar method
async runL0Radar(): Promise<void> {
  const startTime = Date.now()
  
  try {
    // Fetch available cargo from marketplace API
    const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/cargo/agent-compatible`)
    const cargoOffers = await response.json()
    
    // Log findings
    await this.logActivity('L0', 'RADAR_SCAN', {
      offersFound: cargoOffers.length,
      newOffers: cargoOffers.filter(c => c.status === 'NEW').length,
      openOffers: cargoOffers.filter(c => c.status === 'OPEN').length
    }, true, Date.now() - startTime)
    
    // Store in cache for L1 processing
    await this.cacheOffers(cargoOffers)
    
  } catch (error) {
    await this.logActivity('L0', 'RADAR_SCAN', null, false, Date.now() - startTime, error.message)
    throw error
  }
}

private async cacheOffers(offers: any[]): Promise<void> {
  // Cache offers for efficient L1 processing
  for (const offer of offers) {
    await pool.query(`
      INSERT INTO agent_offer_cache (
        cargo_id, offer_data, expires_at
      ) VALUES ($1, $2, NOW() + INTERVAL '1 hour')
      ON CONFLICT (cargo_id) 
      DO UPDATE SET offer_data = $2, expires_at = NOW() + INTERVAL '1 hour'
    `, [offer.id, JSON.stringify(offer)])
  }
}
```

**Update L1 Calculator**:

```typescript
async runL1Calculator(): Promise<ProductionSuggestion[]> {
  const startTime = Date.now()
  
  try {
    // Get cached offers from L0
    const cargoResult = await pool.query(`
      SELECT 
        cargo_id,
        offer_data::jsonb as cargo_data
      FROM agent_offer_cache 
      WHERE expires_at > NOW()
      AND cargo_id NOT IN (
        SELECT cargo_id FROM agent_suggestions 
        WHERE created_at > NOW() - INTERVAL '6 hours'
        AND status IN ('PENDING', 'SENT')
      )
    `)
    
    // Get active vehicles
    const vehiclesResult = await pool.query(`
      SELECT * FROM vehicles 
      WHERE status = 'ACTIVE'
      AND (
        gps_enabled = FALSE OR 
        (gps_enabled = TRUE AND last_seen_ts > NOW() - INTERVAL '30 minutes')
      )
    `)
    
    // Process each combination
    const suggestions: ProductionSuggestion[] = []
    
    for (const cargoRow of cargoResult.rows) {
      const cargo = cargoRow.cargo_data
      
      for (const vehicle of vehiclesResult.rows) {
        // Apply business rules
        if (cargo.weight > vehicle.capacity * 1000) continue
        
        // Calculate and score
        const suggestion = await this.processCombination(cargo, vehicle)
        if (suggestion && suggestion.score >= 5) {
          suggestions.push(suggestion)
        }
      }
    }
    
    // Return top suggestions
    return suggestions
      .sort((a, b) => b.score - a.score)
      .slice(0, 10)
    
  } catch (error) {
    await this.logActivity('L1', 'CALCULATOR_RUN', null, false, Date.now() - startTime, error.message)
    throw error
  }
}
```

---

### 4. QUOTE SUBMISSION WORKFLOW

**Update L2 Quote Bot**:

```typescript
async runL2QuoteBot(): Promise<void> {
  const startTime = Date.now()
  let sentCount = 0
  
  try {
    // Get high-scoring pending suggestions
    const result = await pool.query(`
      SELECT s.*, c.offer_data::jsonb as cargo_data
      FROM agent_suggestions s
      JOIN agent_offer_cache c ON c.cargo_id = s.cargo_id
      WHERE s.status = 'PENDING' 
      AND s.score >= 7
      AND s.created_at > NOW() - INTERVAL '2 hours'
      ORDER BY s.score DESC
      LIMIT 3
    `)
    
    for (const suggestion of result.rows) {
      try {
        // Submit quote via marketplace API
        const response = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/offer-requests`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            cargoId: suggestion.cargo_id,
            proposedPrice: suggestion.suggested_quote,
            message: `AI-optimized quote: €${suggestion.suggested_quote} for ${suggestion.cargo_data.weight}kg cargo. Vehicle ready for immediate dispatch.`,
            agentSuggestionId: suggestion.id
          })
        })
        
        if (response.ok) {
          sentCount++
          console.log(`✅ Quote sent for cargo ${suggestion.cargo_id}`)
        } else {
          console.error(`❌ Failed to send quote for cargo ${suggestion.cargo_id}`)
        }
        
      } catch (quoteError) {
        console.error(`Quote submission error:`, quoteError)
      }
    }
    
    await this.logActivity('L2', 'QUOTE_BOT_RUN', {
      quotesSent: sentCount,
      quotesAttempted: result.rows.length
    }, true, Date.now() - startTime)
    
  } catch (error) {
    await this.logActivity('L2', 'QUOTE_BOT_RUN', null, false, Date.now() - startTime, error.message)
    throw error
  }
}
```

---

### 5. FEEDBACK INTEGRATION

**Create**: `/app/api/agent/feedback/route.ts`

```typescript
import { NextRequest } from 'next/server'
import { pool } from '@/lib/db'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { suggestionId, feedbackType, actualProfit, notes } = body
    
    // Record feedback
    const result = await pool.query(`
      INSERT INTO agent_feedback (
        suggestion_id, feedback_type, profit_actual, notes
      ) VALUES ($1, $2, $3, $4)
      RETURNING *
    `, [suggestionId, feedbackType, actualProfit || null, notes || null])
    
    // Update suggestion with feedback
    await pool.query(`
      UPDATE agent_suggestions 
      SET status = CASE 
        WHEN $2 = 'THUMBS_UP' THEN 'ACCEPTED'
        WHEN $2 = 'THUMBS_DOWN' THEN 'REJECTED'
        ELSE status
      END
      WHERE id = $1
    `, [suggestionId, feedbackType])
    
    return Response.json(result.rows[0], { status: 201 })
    
  } catch (error) {
    return Response.json({ error: 'Failed to record feedback' }, { status: 500 })
  }
}
```

---

### 6. MARKETPLACE UI UPDATES

**Update**: `/app/marketplace/[id]/page.tsx`

Show when offers come from AI Agent:

```typescript
// In the offers display section
{offers.map((offer) => (
  <div key={offer.id} className="bg-[#363636] rounded-lg p-3">
    <div className="flex justify-between items-start mb-2">
      <div className="flex items-center gap-2">
        <p className="text-white text-lg font-bold">
          €{formatPrice(offer.proposedPrice)}
        </p>
        {offer.provider_name === 'FleetOpia AI Agent' && (
          <span className="bg-blue-500 text-white text-xs px-2 py-1 rounded-full font-medium">
            🤖 AI Generated
          </span>
        )}
      </div>
      {/* ... rest of offer display ... */}
    </div>
  </div>
))}
```

---

### 7. ADDITIONAL DATABASE UPDATES

**Add to schema**:

```sql
-- Offer cache for agent processing
CREATE TABLE IF NOT EXISTS agent_offer_cache (
  cargo_id TEXT PRIMARY KEY,
  offer_data JSONB NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  FOREIGN KEY (cargo_id) REFERENCES cargo(id)
);

-- Add agent reference to offer_requests
ALTER TABLE offer_requests 
ADD COLUMN agent_suggestion_id TEXT,
ADD COLUMN responded_at TIMESTAMP;

-- Index for performance
CREATE INDEX IF NOT EXISTS idx_offer_cache_expires ON agent_offer_cache(expires_at);
CREATE INDEX IF NOT EXISTS idx_offers_agent_suggestion ON offer_requests(agent_suggestion_id);
```

---

## 🚨 INTEGRATION DEPENDENCIES

### Marketplace Requirements:
- Existing cargo table with coordinates
- Existing offer_requests table
- Geocoding completed for all cargo

### API Compatibility:
- Marketplace APIs return JSON
- Standard HTTP status codes
- Consistent error handling

### Business Logic:
- Maximum offers per cargo (prevent spam)
- Agent quote acceptance criteria
- Feedback loop for learning

---

## 🧪 TESTING INTEGRATION

### 1. End-to-End Flow:
```bash
# Test complete agent workflow:
1. Create cargo in marketplace
2. Agent L0 scans and finds cargo
3. Agent L1 generates suggestion
4. Agent L2 sends quote automatically
5. Accept/reject quote in marketplace
6. Verify feedback recorded in agent system
```

### 2. Performance Testing:
- Agent processing time < 30 seconds
- Marketplace API response time < 500ms
- No duplicate quotes sent
- Proper error handling

---

**ESTIMATED INTEGRATION TIME**: 4-6 hours  
**COMPLEXITY**: Medium  
**RISK LEVEL**: Low (builds on existing systems)