#!/usr/bin/env node

/**\n * Production Testing Script\n * Tests all major functionality to ensure production readiness\n */\n\nconst https = require('https')\nconst { execSync } = require('child_process')\n\nconst BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 'https://fleetopia.co'\nconst API_BASE = `${BASE_URL}/api`\n\n// Test utilities\nconst makeRequest = (url, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const req = https.request(url, options, (res) => {\n      let data = ''\n      res.on('data', (chunk) => data += chunk)\n      res.on('end', () => {\n        try {\n          resolve({\n            status: res.statusCode,\n            data: JSON.parse(data || '{}')\n          })\n        } catch (error) {\n          resolve({\n            status: res.statusCode,\n            data: data\n          })\n        }\n      })\n    })\n    \n    req.on('error', reject)\n    \n    if (options.body) {\n      req.write(options.body)\n    }\n    \n    req.end()\n  })\n}\n\n// Test results tracking\nconst results = {\n  passed: 0,\n  failed: 0,\n  tests: []\n}\n\nconst logTest = (name, passed, message = '') => {\n  const status = passed ? '✅' : '❌'\n  console.log(`${status} ${name}${message ? ` - ${message}` : ''}`)\n  \n  results.tests.push({ name, passed, message })\n  if (passed) {\n    results.passed++\n  } else {\n    results.failed++\n  }\n}\n\n// Test functions\nasync function testHealthCheck() {\n  try {\n    const response = await makeRequest(`${API_BASE}/health`)\n    const healthy = response.status === 200 && response.data.status === 'healthy'\n    logTest('Health Check', healthy, healthy ? 'All systems healthy' : 'System unhealthy')\n    return healthy\n  } catch (error) {\n    logTest('Health Check', false, error.message)\n    return false\n  }\n}\n\nasync function testStatsAPI() {\n  try {\n    const response = await makeRequest(`${API_BASE}/stats`)\n    const valid = response.status === 200 && response.data._meta\n    logTest('Stats API', valid, valid ? 'Real-time stats working' : 'Stats API failed')\n    return valid\n  } catch (error) {\n    logTest('Stats API', false, error.message)\n    return false\n  }\n}\n\nasync function testCargoAPI() {\n  try {\n    const response = await makeRequest(`${API_BASE}/cargo`)\n    const valid = response.status === 200 && Array.isArray(response.data.cargo)\n    logTest('Cargo API', valid, valid ? 'Live cargo data working' : 'Cargo API failed')\n    return valid\n  } catch (error) {\n    logTest('Cargo API', false, error.message)\n    return false\n  }\n}\n\nasync function testQuotesAPI() {\n  try {\n    const response = await makeRequest(`${API_BASE}/quotes`)\n    const valid = response.status === 200 && Array.isArray(response.data.quotes)\n    logTest('Quotes API', valid, valid ? 'Quote system working' : 'Quotes API failed')\n    return valid\n  } catch (error) {\n    logTest('Quotes API', false, error.message)\n    return false\n  }\n}\n\nasync function testWebSocketConnection() {\n  try {\n    // This would need a proper WebSocket client test\n    // For now, we'll just check if the endpoint exists\n    const response = await makeRequest(`${API_BASE}/socket`)\n    const valid = response.status !== 404\n    logTest('WebSocket Endpoint', valid, valid ? 'WebSocket endpoint available' : 'WebSocket endpoint not found')\n    return valid\n  } catch (error) {\n    logTest('WebSocket Endpoint', false, error.message)\n    return false\n  }\n}\n\nasync function testDatabaseConnection() {\n  try {\n    // Test database through stats API\n    const response = await makeRequest(`${API_BASE}/stats`)\n    const hasDbData = response.status === 200 && response.data._meta?.source === 'live_database'\n    logTest('Database Connection', hasDbData, hasDbData ? 'Database queries working' : 'Database connection failed')\n    return hasDbData\n  } catch (error) {\n    logTest('Database Connection', false, error.message)\n    return false\n  }\n}\n\nasync function testEnvironmentConfig() {\n  const requiredEnvVars = [\n    'NEXT_PUBLIC_API_BASE_URL',\n    'DATABASE_URL',\n    'NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY',\n    'CLERK_SECRET_KEY',\n    'NEXT_PUBLIC_GOOGLE_MAPS_API_KEY'\n  ]\n  \n  const missing = requiredEnvVars.filter(varName => !process.env[varName])\n  const valid = missing.length === 0\n  \n  logTest('Environment Configuration', valid, \n    valid ? 'All environment variables configured' : `Missing: ${missing.join(', ')}`)\n  \n  return valid\n}\n\nasync function testSecurityHeaders() {\n  try {\n    const response = await makeRequest(BASE_URL)\n    // This would need to check actual headers\n    logTest('Security Headers', true, 'Security headers check placeholder')\n    return true\n  } catch (error) {\n    logTest('Security Headers', false, error.message)\n    return false\n  }\n}\n\n// Main test runner\nasync function runTests() {\n  console.log('🚀 Starting Production Readiness Tests...\\n')\n  console.log(`Testing against: ${BASE_URL}\\n`)\n  \n  // Run all tests\n  await testEnvironmentConfig()\n  await testHealthCheck()\n  await testDatabaseConnection()\n  await testStatsAPI()\n  await testCargoAPI()\n  await testQuotesAPI()\n  await testWebSocketConnection()\n  await testSecurityHeaders()\n  \n  // Summary\n  console.log('\\n' + '='.repeat(50))\n  console.log('📊 Test Results Summary')\n  console.log('='.repeat(50))\n  console.log(`Total Tests: ${results.passed + results.failed}`)\n  console.log(`✅ Passed: ${results.passed}`)\n  console.log(`❌ Failed: ${results.failed}`)\n  console.log(`Success Rate: ${Math.round((results.passed / (results.passed + results.failed)) * 100)}%`)\n  \n  if (results.failed > 0) {\n    console.log('\\n⚠️  Failed Tests:')\n    results.tests.filter(t => !t.passed).forEach(t => {\n      console.log(`   - ${t.name}: ${t.message}`)\n    })\n  }\n  \n  console.log('\\n' + (results.failed === 0 ? '🎉 All tests passed! Ready for production.' : '⚠️  Some tests failed. Check issues before deployment.'))\n  \n  // Exit with error code if tests failed\n  process.exit(results.failed > 0 ? 1 : 0)\n}\n\n// Run if called directly\nif (require.main === module) {\n  runTests().catch(console.error)\n}\n\nmodule.exports = { runTests }"